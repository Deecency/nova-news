import 'dart:convert';import 'package:dio/dio.dart';import 'package:flutter/foundation.dart';import 'package:flutter_bloc/flutter_bloc.dart';import 'package:news_app/cubits/error_cubit.dart';import 'package:news_app/shared/globals.dart';import 'package:news_app/shared/shared.dart';import 'package:talker/talker.dart';class ErrorHandler implements Exception {  String _errorMessage = "";  int _statusCode = 0;  ErrorHandler(this._errorMessage, this._statusCode);  ErrorHandler.dioException({required DioException error}) {    _errorHandler(error);  }  ErrorHandler.otherException({dynamic error}) {    _errorHandler(error);  }  getErrorMessage() {    return _errorMessage;  }  getStatusCode() {    return _statusCode;  }  void _errorHandler(dynamic error) async {    if (error is DioException) {      await _handleDioException(error).then((_) => _displayError(e: error));    } else {      await _handleOtherException().then((_) => _displayError(e: error));    }  }  Future _handleOtherException() async {    _errorMessage = "Something went Wrong";    _statusCode = K.unknownError;    ErrorHandler serverError = ErrorHandler(_errorMessage, _statusCode);    return serverError;  }  Future _handleDioException(DioException error) async {    ErrorHandler serverError;    Talker().log("${error.type}", logLevel: LogLevel.error);    switch (error.type) {      case DioExceptionType.cancel:        _errorMessage = "Request Canceled";        _statusCode = error.response?.statusCode ?? K.requestCanceled;        serverError = ErrorHandler(_errorMessage, _statusCode);        break;      case DioExceptionType.connectionTimeout:        _errorMessage = "Connection time out";        _statusCode = error.response?.statusCode ?? K.connectionTimeout;        serverError = ErrorHandler(_errorMessage, _statusCode);        break;      case DioExceptionType.receiveTimeout:        _errorMessage = "Received timeout";        _statusCode = error.response?.statusCode ?? K.receiveTimeout;        serverError = ErrorHandler(_errorMessage, _statusCode);        break;      case DioExceptionType.badResponse:        if (error.response!.statusCode != null &&            error.response!.statusCode! >= 500 &&            error.response!.statusCode! < 600) {          _errorMessage = "Something went wrong";          _statusCode = error.response!.statusCode!;          serverError = ErrorHandler(_errorMessage, _statusCode);        } else if (error.response?.statusCode != 401) {          if (error.response?.data is Map<String, dynamic>) {            _errorMessage = _handleBadRequest(error.response?.data as Map<String, dynamic>);          } else {            _errorMessage = "Something went wrong";          }          _statusCode = error.response!.statusCode!;          serverError = ErrorHandler(_errorMessage, _statusCode);        } else {          _errorMessage = "Unauthorized";          _statusCode = error.response!.statusCode!;          serverError = ErrorHandler(_errorMessage, _statusCode);        }        break;      case DioExceptionType.unknown:        _errorMessage = "Something went wrong";        _statusCode = error.response?.statusCode ?? K.unknownError;        serverError = ErrorHandler(_errorMessage, _statusCode);        break;      case DioExceptionType.sendTimeout:        if (kReleaseMode) {          _errorMessage = "Something went wrong";          _statusCode = error.response?.statusCode ?? K.receiveTimeout;        } else {          _errorMessage = "Received timeout";          _statusCode = error.response?.statusCode ?? K.receiveTimeout;        }        serverError = ErrorHandler(_errorMessage, _statusCode);        break;      case DioExceptionType.connectionError:        _errorMessage = "No Internet connection";        _statusCode = K.noInternetConnection;        serverError = ErrorHandler(_errorMessage, _statusCode);        break;      default:        _errorMessage = error.response?.statusMessage ?? "Something went wrong";        _statusCode = error.response?.statusCode ?? K.unknownError;        serverError = ErrorHandler(_errorMessage, _statusCode);        break;    }    return serverError;  }  String _handleBadRequest(Map<String, dynamic>? errorData) {    String error = "";    if (errorData?["code"] != null) {      final message = errorData?["code"];      error = message;    } else if (errorData?['error'] != null) {      try {        final errorObject = errorData?['error'];        final message = errorObject['message'];        final dynamic errorTag = message.keys.first;        error = message[errorTag];      } catch (e) {        error = errorData?['error']['message'] ?? "";      }    } else if (errorData?['errors'] == null && errorData?.entries != null) {      for (var item in errorData!.entries) {        error = item.value.toString();        break;      }    } else {      error = "Something went wrong";    }    return error;  }  void _displayError({required e, data}) {    String message = "";    String resMessage = "";    int? statusCode;    if (e is DioException) {      message = getErrorMessage();      statusCode = getStatusCode();      resMessage = statusCode == K.noInternetConnection          ? "Check your internet connection and try again!"          : "";      if (e.response != null && (e.message != null || e.response!.data!["message"] != null)) {        if (statusCode != null && statusCode != K.noInternetConnection) {          resMessage = statusCode == 404              ? "The request contains bad syntax or cannot be fulfilled"              : (e.response!.data!["message"] ?? e.response?.statusMessage ?? e.message);        }      }    } else {      message = getErrorMessage();      statusCode = getStatusCode();    }    Map<String, dynamic> errorData = {};    errorData = {      "error": message,      "message": resMessage,      "statusCode": statusCode,      "loginData": data,    };    showErrorModal(errorData);  }}Future<void> showErrorModal(Map<String, dynamic> error) async {  final context = navigatorKey.currentContext;  if (context != null) {    context.read<ErrorCubit>().showError(error, context: context);  }}